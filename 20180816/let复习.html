<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <ul>
        <li>1</li>
        <li>2</li>
        <li>3</li>
        <li>4</li>
        <li>5</li>
        <li>6</li>
    </ul>
    <script>
        var list_li = document.getElementsByTagName('li')
        // for(var i =0;i<list_li.length;i++){
        //     list_li[i].onclick = function(){
        //         console.log(i)
        //     }
        // }
        // //返回结果: 6 6 6 6 6 6 原因就是：js是单线程，有异步队列，在该执行完函数调用栈中的代码，然后立即调用click函数。
        // //这是因为，我们的函数(定时器)都被放在了一个被称为队列的数据结构中，等待上下文的可执行代码运行完毕后，才开始运行函数(定时器)，所以在函数执行的时候，变量i已经变成了6

        // for(var i = 0;i<5;i++){

        // }   //=>
        // var i 
        // for(i=0;i<5;i++)
        // //所以在for循环体外部是可以拿到这个i的

        // 如果想输出 0 1 2 3 4 5 只需将var改为let即可
        // 如果是点击谁输出几呢？
        // 1、
        // 利用let，来保存该i为私有变量
        // for(let i =0;i<list_li.length;i++){
        //     list_li[i].onclick = function(){
        //         console.log(i+1)
        //     }
        // }
        
        // 2、
        // 利用闭包，原理和let相同
        // for(var i =0;i<list_li.length;i++){
        //     list_li[i].onclick = function(){
        //         return function(i){
        //             console.log(i+1)
        //         }
        //     }
        // }

        // 3、
        // 巧用this（佳哥推荐），不修改原来代码，也不用let和闭包
        for(var i =0;i<list_li.length;i++){
            list_li[i].onclick = function(){
                console.log(this.innerHTML)
            }
        }
        this就是当前这个i，因为i被提取出去了


        补充+复习:
        var i;
        if(true){
            i = 5;
            let i;
        }
        alert(i)
        //报错：i is not defined 有一个概念叫：暂时性死区，在{}这个块呢，es6规定，在找到i时，必须是先定义后使用，故而在定义前的使用都是无效的，故而，报错，是i没有没定义
    </script>
</body>
</html>